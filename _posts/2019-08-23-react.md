---
layout:     post                  #不要管他
title:      从零开始学React     #标题
subtitle:   React              #别名,简介,标题下面的那一行字
date:       2019-08-23            #发表时间
author:     Zhaolai                    #作者
header-img: img/post-bg-rwd.jpg   #背景图片
catalog: true                     #导航目录,不要管他
original: true                    #是否原创申明
tags:                             #标签,可以有多个
    - 组件化
    - react
    - 前端
---
# React

一个视图库

## npm

1. `npm install -g 包名`安装一个node包  其中-g是全局的包
2. `npm init -y`初始化创建package.json
3. `npm install 包名`安装一个node包
4. `npm uninstall 包名`删除一个包

## 创建React

1. `npm install -g create-react-app`创建全局包
2. `create-react-app 应用名`创建一个react应用
3. 组件的地址为`src/App.test.js`
4. 测试脚本`npm test`
5. 创建一个文件夹用来部署应用`npm run 文件夹名`

## 使用React

```
import React,{Component} from "react";
import './App.css';
class App extends Component {
	render(){													包含了他返回的元素
    	var hello = 'hello world';				定义一个变量
    	return (
        	<div className="App">
            	<p>{hello}</p>							使用变量
        	</div>
    	);
    }
}
export default App;
```

### 属性

1. className 类名

### 声明

1. const无法被重新赋值或重新声明,当声明的是数组或对象时内容可以更新,但是数据结构不可以改变

2. let可以改变

3. 使用const代替var, 只有必须使用let时使用let

### 结构

   1. `public/index.html`设置被修改的元素

   2. `src/index.js`写入修改的内容和被修改的元素间的联系

   3. `src/App.js`写入修改的内容

### 特点
   1. 自动刷新页面以修改内容

   2. index.js添加代码, 使浏览器重新加载应用,而不刷新页面

      ```
      if (module.hot) {
      	module.hot.accept();
      }
      ```

### map函数

```
import React,{Component} from "react";
import './App.css';
const list = [{name:"zhaolai",age:26,like:"game"},{name:"liuchuan",age:28,like:"basketball"},{name:"abc",age:21,like:2424}];										列表
class App extends Component {
  render(){                  
    return (
      <div className="App">
        {list.map(function(item){        							遍历
          return (
            <div key={item.age}>   										取值, 命名key
              <h1>{item.name}</h1>
              <h2>{item.age}</h2>
              <h3>{item.like}</h3>
            </div>
          );
        })}
      </div>
    );
  }
}
export default App;
```
###  箭头函数

```
   function(参数){
   	函数体
   }
   (参数)=>{
   	函数体
   }
```

   当有一个参数的时候小括号可以省略

```
   当函数体为
   return(
   返回的内容
   );
   可以直接写作
   (参数)=>返回的内容
```

### 类

```
import React,{Component} from 'react';				导包
import './App.css';
class human{																	定义一个类
  constructor(firstname,lastname){							初始化
    this.firstname = firstname;
    this.lastname = lastname;
  }
  getName(){    																	定义方法
    return this.firstname+this.lastname;
  }
}
class App extends Component{									继承
  render(){																				重载输出方法
    const zhaolai = new human("zhao","lai");				实例化
    console.log(zhaolai.getName());									对象调用方法
    return (
      <div className="zhaolai">
        <span>{zhaolai.getName()}</span>
      </div>
    );
  }
}
export default App;

```

继承

```
import React,{Component} from "react";
class App extends Component{
	render(){					这个方法必须被重载,他是组件的输出
		...
	}
}
```

## React基础

### 构造函数

```
import React,{Component} from "react";                                                   导包
import './App.css';
const list = [{name:"zhaolai",age:26,like:"game"},									列表
{name:"liuchuan",age:28,like:"basketball"},
{name:"abc",age:21,like:2424}];
class App extends Component {																		定义一个类继承Component
  constructor(say){																									构造函数
    super(say);																												强制使用super()添加参数的属性
    this.abc = {																											将列表添加为abc的属性内
      list:list,
    };
  }
  render(){                  																									输出函数
    return (
      <div className="App">
        {this.abc.list.map(function(item){																遍历列表
          return (
            <div key={item.age}>
              <h1>{item.name}</h1>
              <h2>{item.age}</h2>
              <h3>{item.like}</h3>
            </div>
          );
        })}
      </div>
    );
  }
}
export default App;
```

### ES6对象初始化

当属性名和值的变量名相同时

```
name:name             ==>             name,
```

初始化对象方法

```
var user = {
	getuesrname : function(user){
		.....
	}
}
ES6
var user = {
	getusername(user){
		.......
	}
}
```

使用计算属性名

```
var user = {
	name : "zhaolai";
}
ES6
const key = "name";
var user = {
	[key] : "zhoalai";
}
```

### 单项数据流

```
import React,{Component} from "react";
import './App.css';
const list = [{name:"zhaolai",age:26,like:"game",id:1},																列表
{name:"liuchuan",age:28,like:"basketball",id:2},
{name:"abc",age:21,like:2424,id:3}];
class App extends Component {																										定义类
  constructor(props){																														初始化魔术方法
    super(props);																				
    this.state = {																				定义属性(一定要叫state 这个是将要更改的变量)
      list,
    };
    this.onDismiss=this.onDismiss.bind(this);																	绑定对象方法
  }
  onDismiss(id){
    console.log(id);
    const updateList = this.state.list.filter(item => item.id !== id);									过滤,如果相同则过滤掉
    this.setState({list:updateList});																					使用setState方法改变state属性并重绘
    console.log(this.state);
  }
  render(){
    return (
      <div className="App">
        {this.state.list.map(item =>
            <div key={item.id}>
              <h1>{item.name}</h1>
              <h2>{item.age}</h2>
              <h3>{item.like}</h3>
              <button onClick={()=>this.onDismiss(item.id)} type="button">删除</button>				按钮的点击事件
            </div>
          )}
      </div>
    );
  }
}
export default App;
```

### 绑定

```
constructor(){
    super();
    this.onClickMe=this.onClickMe.bind(this);
}
```

在构造函数中定义业务逻辑方法,但是需要避免这个,因为会让初始化函数变得很长

```
constructor(){
    super();
    this.onClickMe= ()=>{
    	console.log(this)
    };
}
```

不推荐这个方法,因为每次加载render的时候都会执行绑定函数

```
render(){
    return (
        <div>
            <button type="button" onClick={this.onClickMe.bind(this)}>点我!</button>
        </div>
    );
}
```

使用箭头函数可以直接绑定

```
onClickMe = () => {
    console.log(this);
}
```

### 事件

绑定事件的时候必须绑定一个函数名,而不是函数体,可以使用一个函数将函数体包裹起来. 否则会在加载页面的时候触发

### 与表单交互

```
import React,{Component} from "react";
import './App.css';
const list = [{name:"zhaolai",age:26,like:"game"},								列表
{name:"liuchuan",age:28,like:"basketball"},
{name:"abc",age:21,like:2424}];
const issearched = value => item => item.name.toLowerCase().includes(value.toLowerCase());			设定一个函数判断值是否在列表的name值内
class App extends Component {
    constructor(){
        super();
        this.state = {											设定state属性
            list,
            value:""												搜索的值
        };
        this.onChange = this.onChange.bind(this);								绑定搜索值改变函数
    }
    onChange(event){																						
        this.setState({value:event.target.value});												更改state值,并进行重绘
    }
    render(){
        return (
            <div>
                <form>
                    <input type="text" onChange={this.onChange}/>												输入搜索值
                </form>
                {this.state.list.filter(issearched(this.state.value)).map(function(item){					遍历
                    return (
                        <div key={item.age}>
                            <h1>{item.name}</h1>
                            <h2>{item.age}</h2>
                            <h3>{item.like}</h3>
                        </div>
                    );
                })}
            </div>
        );
    }
}
export default App;
```

### 解构

```
const list = ["zhaolai","liuchuan"];
const [user1,uesr2] = list;										uesr1就是zhaolai, user2就是liuchuan
this.state = {
    list,
    value:""
}
const {list, value} = this.state                            list就是list的值, value就是""
```

### 受控组件

为了避免外部更改信息后,对组件造成修改,

```
render(){
    const {list,value} = this.state;
    return (
        <div>
            <form>
                <input type="text" value={value} onChange={this.onChange}/>			添加value属性,防止修改value后无法控制
            </form>
```

### 组件

1. 函数式无状态组件, 没有this对象, 不能使用生命周期方法
2. ES6 类组件, 就是上面写的那些组件

```
import React,{Component} from "react";
import './App.css';
const list = [{name:"zhaolai",age:26,like:"game"},
{name:"liuchuan",age:28,like:"basketball"},
{name:"abc",age:21,like:2424}];
const issearched = value => item => item.name.toLowerCase().includes(value.toLowerCase());
class App extends Component {
    constructor(){
        super();
        this.state = {
            list,
            value:""
        };
        this.onChange = this.onChange.bind(this);
    }
    onChange(event){
        this.setState({value:event.target.value});
    }
    render(){
        const {list,value} = this.state;
        return (
            <div>
                <Search value={value} onChange={this.onChange}/>                    插入模块的方式
                <Table list={list} pattern={value}/>
            </div>
        );
    }
}
class Search extends Component {																				定义一个类模块
    render(){
        const {value,onChange} = this.props;												获得插入模块时的参数,可以加入children(文本节点)
        return(
            <form>
                <input type="text" defaultValue={value} onChange={onChange}/>
            </form>
        );
    }
}
class Table extends Component {
    render(){
        const {list,pattern} = this.props;
        return(
            <div>
            {list.filter(issearched(pattern)).map(function(item){
                return (
                    <div key={item.age}>
                        <h1>{item.name}</h1>
                        <h2>{item.age}</h2>
                        <h3>{item.like}</h3>
                    </div>
                );
            })}
            </div>
        );
    }
}
export default App;
```

### 样式

1. 使用index.css设置标签的css样式(全局样式)
2. 使用app.css设置对应的组件的样式(局部样式),使用类名className
3. 内联样式`<span style={{ width: '30%' }}>{item.like}</span>`

## API

### 生命周期方法

1. constructor(props) - 它在组件初始化时被调用。在这个方法中,你可以设置初始化状态以及绑定类方法。
2. componentWillMount() - 它在 render() 方法之前被调用。这就是为什么它可以用作去设置组件内部的状态,因为它不会触发组件的再次渲染。但一般来说,还是推荐在 constructor() 中去初始化状态。
3. render() - 这个生命周期方法是必须有的,它返回作为组件输出的元素。这个方法应该是一个纯函数,因此不应该在这个方法中修改组件的状态。它把属性和状态作为输入并且返回(需要渲染的)元素
4. componentDidMount() - 它仅在组件挂载后执行一次。这是发起异步请求去API获取数据的绝佳时期。获取到的数据将被保存在内部组件的状态中然后在 render() 生命周期方法中展示出来。
5. componentWillReceiveProps(nextProps) - 这个方法在一个更新生命周(update lifecycle)中被调用。新的属性会作为它的输入。因此你可以利用 this.props 来对比之后的属性和之前的属性,基于对比的结果去实现不同的行为。此外,你可以基于新的属性来设置组件的状态。
6. shouldComponentUpdate(nextProps, nextState) - 每次组件因为状态或者属性更改而更新时,它都会被调用。你将在成熟的 React 应用中使用它来进行性能优化。在一个更新生命周期中,组件及其子组件将根据该方法返回的布尔值来决定是否重新渲染。这样你可以阻止组件的渲染生命周期(render lifecycle)方法,避免不必要的渲染。
7. componentWillUpdate(nextProps, nextState) - 这个方法是 render() 执行之前的最后一 个 方 法。 你 已 经 拥 有 下 一 个 属 性 和 状 态, 它 们 可 以 在 这 个 方 法 中 任 由 你 处置。你可以利用这个方法在渲染之前进行最后的准备。注意在这个生命周期方法 中 你 不 能 再 触 发 setState() 。如 果 你 想 基 于 新 的 属 性 计 算 状 态, 你 必 须 利 用componentWillReceiveProps() 。
8. componentDidUpdate(prevProps, prevState) - 这个方法在 render() 之后立即调用。你可以用它当成操作 DOM 或者执行更多异步请求的机会。
9. componentWillUnmount() - 它会在组件销毁之前被调用。你可以利用这个生命周期方法去执行任何清理任务。
10. componentDidCatch(error, info)捕获错误信息

### 获得数据

```
import React,{Component} from "react";
import './App.css';
const DEFAULT_QUERY = 'redux';												设置默认值
const PATH_BASE = 'https://hn.algolia.com/api/v1';
const PATH_SEARCH = '/search';
const PARAM_SEARCH = 'query=';
const issearched = value => item => item.title.toLowerCase().includes(value.toLowerCase());
class App extends Component {
    constructor(){
        super();
        this.state = {
            result:null,																				初始结果为null
            searchTerm:DEFAULT_QUERY											搜索值为默认值
        };
        this.onChange = this.onChange.bind(this);
        this.setSearchTopStories = this.setSearchTopStories.bind(this);
        this.fetchSearchTopStories = this.fetchSearchTopStories.bind(this);
        this.onDismiss = this.onDismiss.bind(this);
    }
    onDismiss(objectID){
        const updateList = this.state.result.hits.filter(item => item.objectID !== objectID);
        this.setState({result:{...this.state.result, hits: updateList}});								删除功能,将复杂的对象合并,扩展操作符
        console.log(this.state);
    }
    onChange(event){
        this.setState({searchTerm:event.target.value});
    }
    setSearchTopStories(result) {																							No.3
        console.log(result);
        this.setState({ result });
    }
    fetchSearchTopStories(searchTerm) {																				No.2
        fetch(`${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}`)
            .then(response => response.json())
            .then(result => this.setSearchTopStories(result))
            .catch(e => e);
    }
    componentDidMount() {																										No.1
        const { searchTerm } = this.state;
        this.fetchSearchTopStories(searchTerm);
    }
    render(){
        if(!this.state.result){return null}																					第一次加载时内容为空所以返回空
        const {result,searchTerm} = this.state;
        return (
            <div>
                <Search value={searchTerm} onChange={this.onChange}/>
                <Table list={result} pattern={searchTerm} onDismiss={this.onDismiss}/>
            </div>
        );
    }
}
class Search extends Component {
    render(){
        const {value,onChange} = this.props;
        return(
            <form>
                <input type="text" value={value} onChange={onChange}/>
            </form>
        );
    }
}
class Table extends Component {
    render(){
        const {list,pattern,onDismiss} = this.props;
        return(
            <div className="table">
            {list.hits.filter(issearched(pattern)).map(function(item){
                return (
                    <div key={item.objectID}>
                        <h1>{item.title}</h1>
                        <h2>{item.author}</h2>
                        <h3>{item.points}</h3>
                        <button onClick={()=>onDismiss(item.objectID)} type="button">删除</button>
                    </div>
                );
            })}
            </div>
        );
    }
}
export default App;
```

### 搜索

```
import React,{Component} from "react";
import './App.css';
const DEFAULT_QUERY = 'redux';
const PATH_BASE = 'https://hn.algolia.com/api/v1';
const PATH_SEARCH = '/search';
const PARAM_SEARCH = 'query=';
class App extends Component {
    constructor(){
        super();
        this.state = {
            result:null,
            searchTerm:DEFAULT_QUERY
        };
        this.onChange = this.onChange.bind(this);
        this.setSearchTopStories = this.setSearchTopStories.bind(this);
        this.fetchSearchTopStories = this.fetchSearchTopStories.bind(this);
        this.onDismiss = this.onDismiss.bind(this);
        this.onSearchSubmit = this.onSearchSubmit.bind(this);
    }
    onDismiss(objectID){
        const updateList = this.state.result.hits.filter(item => item.objectID !== objectID);
        this.setState({result:{...this.state.result, hits: updateList}});
        console.log(this.state);
    }
    onChange(event){
        this.setState({searchTerm:event.target.value});
        console.log(this.state);
    }
    onSearchSubmit(event) {																									增加一个搜索功能
        const { searchTerm } = this.state;
        console.log(searchTerm);
        this.fetchSearchTopStories(searchTerm);
        event.preventDefault();																									阻止默认行为,跳转
    }
    setSearchTopStories(result) {
        console.log(result);
        this.setState({ result });
    }
    fetchSearchTopStories(searchTerm) {
        fetch(`${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}`)
            .then(response => response.json())
            .then(result => this.setSearchTopStories(result))
            .catch(e => e);
    }
    componentDidMount() {
        const { searchTerm } = this.state;
        this.fetchSearchTopStories(searchTerm);
    }
    render(){
        if(!this.state.result){return null}
        const {result,searchTerm} = this.state;
        return (
            <div>
                <Search value={searchTerm} onChange={this.onChange} onSubmit={this.onSearchSubmit}/>
                {result && <Table list={result} onDismiss={this.onDismiss}/>
                }
            </div>
        );
    }
}
class Search extends Component {
    render(){
        const {value,onChange,onSubmit} = this.props;
        return(
            <form onSubmit={onSubmit}>																									提交功能
                <input type="text" value={value} onChange={onChange}/>
                <button type="submit">搜索</button>																			    按钮
            </form>
        );
    }
}
class Table extends Component {
    render(){
        const {list,onDismiss} = this.props;
        return(
            <div className="table">
            {list.hits.map(function(item){
                return (
                    <div key={item.objectID}>
                        <h1>{item.title}</h1>
                        <h2>{item.author}</h2>
                        <h3>{item.points}</h3>
                        <button onClick={()=>onDismiss(item.objectID)} type="button">删除</button>
                    </div>
                );
            })}
            </div>
        );
    }
}
export default App;
```

### 分页

```
import React,{Component} from "react";
import './App.css';
const DEFAULT_QUERY = 'redux';
const PATH_BASE = 'https://hn.algolia.com/api/v1';
const PATH_SEARCH = '/search';
const PARAM_SEARCH = 'query=';
const PARAM_PAGE = 'page=';																													添加一个参数
class App extends Component {
    constructor(){
        super();
        this.state = {
            result:null,
            searchTerm:DEFAULT_QUERY
        };
        this.onChange = this.onChange.bind(this);
        this.setSearchTopStories = this.setSearchTopStories.bind(this);
        this.fetchSearchTopStories = this.fetchSearchTopStories.bind(this);
        this.onDismiss = this.onDismiss.bind(this);
        this.onSearchSubmit = this.onSearchSubmit.bind(this);
    }
    onDismiss(objectID){
        const updateList = this.state.result.hits.filter(item => item.objectID !== objectID);
        this.setState({result:{...this.state.result, hits: updateList}});
        console.log(this.state);
    }
    onChange(event){
        this.setState({searchTerm:event.target.value});
        console.log(this.state);
    }
    onSearchSubmit(event) {
        const { searchTerm } = this.state;
        console.log(searchTerm);
        this.fetchSearchTopStories(searchTerm);
        event.preventDefault();
    }
    setSearchTopStories(result) {
        const { hits, page } = result;
        const oldHits = page !== 0
            ? this.state.result.hits												判断页码为0时旧内容为空,不为0时旧内容为以前的值hits
            : [];
        const updatedHits = [
            ...oldHits,																							合并新旧列表										
            ...hits
        ];
        this.setState({
            result: { hits: updatedHits, page }										将结果更新为hits和page
        });
    }
    fetchSearchTopStories(searchTerm,page=0) {				默认页数为0									新加的参数page
        fetch(`${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}&${PARAM_PAGE}${page}`)
            .then(response => response.json())
            .then(result => this.setSearchTopStories(result))
            .catch(e => e);
    }
    componentDidMount() {
        const { searchTerm } = this.state;
        this.fetchSearchTopStories(searchTerm);
    }
    render(){
        if(!this.state.result){return null}
        const {result,searchTerm} = this.state;
        const page = (result&&result.page)||0;					判断页码,如果结果为空,那么页码为0,如果不为空那么页码为当前页码
        return (
            <div>
                <Search value={searchTerm} onChange={this.onChange} onSubmit={this.onSearchSubmit}/>
                {result && <Table list={result} onDismiss={this.onDismiss}/>}
                <button onClick={() => this.fetchSearchTopStories(searchTerm, page+1)}>more</button>
            </div>																		新增一个按钮,点击事件触发请求
        );
    }
}
class Search extends Component {
    render(){
        const {value,onChange,onSubmit} = this.props;
        return(
            <form onSubmit={onSubmit}>
                <input type="text" value={value} onChange={onChange}/>
                <button type="submit">搜索</button>
            </form>
        );
    }
}
class Table extends Component {
    render(){
        const {list,onDismiss} = this.props;
        return(
            <div className="table">
            {list.hits.map(function(item){
                return (
                    <div key={item.objectID}>
                        <h1>{item.title}</h1>
                        <h2>{item.author}</h2>
                        <h3>{item.points}</h3>
                        <button onClick={()=>onDismiss(item.objectID)} type="button">删除</button>
                    </div>
                );
            })}
            </div>
        );
    }
}
export default App;
```

### 缓存

```
import React,{Component} from "react";
import './App.css';
const DEFAULT_QUERY = 'redux';
const PATH_BASE = 'https://hn.algolia.com/api/v1';
const PATH_SEARCH = '/search';
const PARAM_SEARCH = 'query=';
const PARAM_PAGE = 'page=';
class App extends Component {
    constructor(){
        super();
        this.state = {
            results:null,
            searchKey:"",																													增加一个用于记录搜索内容的键
            searchTerm:DEFAULT_QUERY
        };
        this.onChange = this.onChange.bind(this);
        this.setSearchTopStories = this.setSearchTopStories.bind(this);					    增加一个用于阻止多次查找的功能
        this.fetchSearchTopStories = this.fetchSearchTopStories.bind(this);
        this.onDismiss = this.onDismiss.bind(this);
        this.onSearchSubmit = this.onSearchSubmit.bind(this);
        this.needsToSearchTopStories = this.needsToSearchTopStories.bind(this);
    }
    onDismiss(objectID){																				删除当前内容,为state下的results下的searchkey下的hits 
        const { searchKey, results } = this.state;
        const { hits, page } = results[searchKey];
        const isNotId = item => item.objectID !== objectID;	
        const updatedHits = hits.filter(isNotId);
        this.setState({
            results: {
                ...results,
                [searchKey]: { hits: updatedHits, page }
            }
        })
    }
    onChange(event){
        this.setState({searchTerm:event.target.value});
    }
    needsToSearchTopStories(searchTerm){
        return !this.state.results[searchTerm];												判断当前的缓存中是否含有当前的搜索内容
    }
    onSearchSubmit(event) {
        const { searchTerm } = this.state;
        this.setState({searchKey : searchTerm})												将搜索内容传入搜索键
        if (this.needsToSearchTopStories(searchTerm)) {							如果缓存中不存在则请求
            this.fetchSearchTopStories(searchTerm);
        }
        event.preventDefault();																				组织请求跳转
    }
    setSearchTopStories(result) {
        const { hits, page } = result;																					新结果
        const { searchKey, results } = this.state;															旧结果
        const oldHits = results && results[searchKey]											如果旧结果不存在该搜索键,则为空列表
            ? results[searchKey].hits
            : [];
        const updatedHits = [																								将新旧结果合并
            ...oldHits,
            ...hits
        ];
        this.setState({																													保存
            results: {
                    ...results,
                    [searchKey]: { hits: updatedHits, page }}
        });
        console.log(this.state);
    }
    fetchSearchTopStories(searchTerm,page=0) {
        fetch(`${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}&${PARAM_PAGE}${page}`)
            .then(response => response.json())
            .then(result => this.setSearchTopStories(result))
            .catch(e => e);
    }
    componentDidMount() {
        const { searchTerm } = this.state;
        this.setState({searchKey : searchTerm})							默认搜索时将传入键
        this.fetchSearchTopStories(searchTerm);
    }
    render(){
        if(!this.state.results){return null}
        const {results, searchKey, searchTerm} = this.state;
        const page = (results&&results[searchKey]&&results[searchKey].page)||0;			如果结果不存在对应页码,则为0
        const list = (results&&results[searchKey]&&results[searchKey].hits)||[];		如果结果不存在对应的键,则为空列表
        return (
            <div>
                <Search value={searchTerm} onChange={this.onChange} onSubmit={this.onSearchSubmit}/>
                {list!==[]&&<Table list={list} onDismiss={this.onDismiss}/>}
                <button onClick={() => this.fetchSearchTopStories(searchKey, page+1)}>more</button>	
            </div>	                                                         								更多时搜索应使用键,避免搜索框内容的更改造成的bug
        );
    }
}
class Search extends Component {
    render(){
        const {value,onChange,onSubmit} = this.props;
        return(
            <form onSubmit={onSubmit}>
                <input type="text" value={value} onChange={onChange}/>
                <button type="submit">搜索</button>
            </form>
        );
    }
}
class Table extends Component {
    render(){
        const {list,onDismiss} = this.props;
        return(
            <div className="table">
            {list.map(function(item){
                return (
                    <div key={item.objectID}>
                        <h1>{item.title}</h1>
                        <h2>{item.author}</h2>
                        <h3>{item.points}</h3>
                        <button onClick={()=>onDismiss(item.objectID)} type="button">删除</button>
                    </div>
                );
            })}
            </div>
        );
    }
}
export default App;
```

### 错误

```
import React,{Component} from "react";
import './App.css';
const DEFAULT_QUERY = 'redux';
const PATH_BASE = 'https://hn.foo.bar.com/api/v1';
const PATH_SEARCH = '/search';
const PARAM_SEARCH = 'query=';
const PARAM_PAGE = 'page=';
class App extends Component {
    constructor(){
        super();
        this.state = {
            results:null,
            searchKey:"",
            searchTerm:DEFAULT_QUERY,
            error:null																												添加一个错误参数
        };
        this.onChange = this.onChange.bind(this);
        this.setSearchTopStories = this.setSearchTopStories.bind(this);
        this.fetchSearchTopStories = this.fetchSearchTopStories.bind(this);
        this.onDismiss = this.onDismiss.bind(this);
        this.onSearchSubmit = this.onSearchSubmit.bind(this);
        this.needsToSearchTopStories = this.needsToSearchTopStories.bind(this);
    }
    onDismiss(objectID){
        const { searchKey, results } = this.state;
        const { hits, page } = results[searchKey];
        const isNotId = item => item.objectID !== objectID;
        const updatedHits = hits.filter(isNotId);
        this.setState({
            results: {
                ...results,
                [searchKey]: { hits: updatedHits, page }
            }
        })
    }
    onChange(event){
        this.setState({searchTerm:event.target.value});
    }
    needsToSearchTopStories(searchTerm){
        return !this.state.results[searchTerm];
    }
    onSearchSubmit(event) {
        const { searchTerm } = this.state;
        this.setState({searchKey : searchTerm})
        if (this.needsToSearchTopStories(searchTerm)) {
            this.fetchSearchTopStories(searchTerm);
        }
        event.preventDefault();
    }
    setSearchTopStories(result) {
        const { hits, page } = result;
        const { searchKey, results } = this.state;
        const oldHits = results && results[searchKey]
            ? results[searchKey].hits
            : [];
        const updatedHits = [
            ...oldHits,
            ...hits
        ];
        this.setState({
            results: {
                    ...results,
                    [searchKey]: { hits: updatedHits, page }}
        });
        console.log(this.state);
    }
    fetchSearchTopStories(searchTerm,page=0) {
        fetch(`${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}&${PARAM_PAGE}${page}`)
            .then(response => response.json())
            .then(result => this.setSearchTopStories(result))
            .catch(e => this.setState({error: e}));																发生错误时捕获
    }
    componentDidMount() {
        const { searchTerm } = this.state;
        this.setState({searchKey : searchTerm})
        this.fetchSearchTopStories(searchTerm);
    }
    render(){
        console.log(this.state);
        const {results, searchKey, searchTerm, error} = this.state;
        const page = (results&&results[searchKey]&&results[searchKey].page)||0;
        const list = (results&&results[searchKey]&&results[searchKey].hits)||[];
        return (
            <div>
                <Search value={searchTerm} onChange={this.onChange} onSubmit={this.onSearchSubmit}/>
                {error																														如果有错误那么输出请求失败
                    ?<p>请求失败,你被封杀了.</p>
                    :<Table list={list} onDismiss={this.onDismiss}/>}
                <button onClick={() => this.fetchSearchTopStories(searchKey, page+1)}>more</button>
            </div>
        );
    }
}
class Search extends Component {	
    render(){
        const {value,onChange,onSubmit} = this.props;
        return(
            <form onSubmit={onSubmit}>
                <input type="text" value={value} onChange={onChange}/>
                <button type="submit">搜索</button>
            </form>
        );
    }
}
class Table extends Component {
    render(){
        const {list,onDismiss} = this.props;
        return(
            <div className="table">
            {list.map(function(item){
                return (
                    <div key={item.objectID}>
                        <h1>{item.title}</h1>
                        <h2>{item.author}</h2>
                        <h3>{item.points}</h3>
                        <button onClick={()=>onDismiss(item.objectID)} type="button">删除</button>
                    </div>
                );
            })}
            </div>
        );
    }
}
export default App;

```

### 导入和导出

1. 导入

   ```
   import {导入的内容} from "文件的路径带后缀";
   import * as 别名 from "文件的路径带后缀";
   import {导入的内容 as 别名} from "文件路径带后缀";
   ```

2. 导出

   ```
   export {导出的内容};
   export default 导出的单一内容;                     这个在导出的时候为  import 别名 from "文件路径带后缀";
   ```

### 代码组织

```
src/
	index.js
App/
	index.js										import {按钮名} from "../Button"  因为导入的是默认的index.js所以可以省略
Buttons/
	index.js										导入所有按钮,并导出所有按钮
	SubmitButton.js
	SaveButton.js
	CancelButton.js
```

### 测试App.test.js

`npm install --save-dev react-test-renderer`

编写完毕后运行`npm test`

```
import React from 'react';
import ReactDOM from 'react-dom';
import App, {Search, Table} from './App';
import renderer from 'react-test-renderer';

describe("App", ()=>{
    it('renders without crashing', () => {
        const div = document.createElement('div');
        ReactDOM.render(<App />, div);
    });
    test('has a valid snapshot', () => {
        const component = renderer.create(<App />);
        let tree = component.toJSON();
        expect(tree).toMatchSnapshot();
    });
});
describe('Search', () => {
    it('renders without crashing', () => {
        const div = document.createElement('div');
        ReactDOM.render(<Search>Search</Search>, div);
    });
    test('has a valid snapshot', () => {
        const component = renderer.create(
            <Search>Search</Search>
        );
        let tree = component.toJSON();
        expect(tree).toMatchSnapshot();
    });
});
describe('Table', () => {
    const props = {
        list: [
            { title: '1', author: '1', num_comments: 1, points: 2, objectID: 'y' },
            { title: '2', author: '2', num_comments: 1, points: 2, objectID: 'z' },
        ],
    };
    it('renders without crashing', () => {
        const div = document.createElement('div');
        ReactDOM.render(<Table { ...props } />, div);
    });
    test('has a valid snapshot', () => {
        const component = renderer.create(
            <Table { ...props } />
        );
        let tree = component.toJSON();
        expect(tree).toMatchSnapshot();
    });
});
```

### 组件接口

`npm install prop-types`

```
import PropTypes from "prop-types";

const Button = ({ onClick, className = '', children }) =>  				设置默认参数方法1
    <button
        onClick={onClick}
        className={className}
        type="button">
        {children}
    </button>;

Button.defaultProps = {																				设置默认参数方法2
    className: '',
};
Button.propTypes = {																					按钮的数据类型
    onClick: PropTypes.func.isRequired,													代表必须要有
    className: PropTypes.string,
    children: PropTypes.node.isRequired,
};
Table.propTypes = {
    list: PropTypes.arrayOf(																			数组的内容
        PropTypes.shape({
            objectID: PropTypes.string.isRequired,
            author: PropTypes.string,
            url: PropTypes.string,
            num_comments: PropTypes.number,
            points: PropTypes.number,
        })
    ).isRequired,
    onDismiss: PropTypes.func.isRequired,
};
```

数据类型

1. PropTypes.array    数组
2. PropTypes.bool    布尔值
3. PropTypes.func    函数
4. PropTypes.number    数值
5. PropTypes.object    对象
6. PropTypes.string    字符串
7. PropTypes.node    文本节点
8. PropTypes.element    react元素

## 高级React组件

### 引入DOM元素

1. 类

```
class Search extends Component {
    componentDidMount() {
        if(this.input){
            this.input.focus();										input聚焦
        }
    }
    render(){
        const {value,onChange,onSubmit,children="搜索"} = this.props;
        return(
            <form onSubmit={onSubmit}>
                <input type="text" value={value} onChange={onChange}
                       ref={(node) => { this.input=node; }}/>																引入DOM元素
                <button type="submit">{children}</button>
            </form>
        );
    }
}
```

2. 无状态组件

   由于无法使用生命周期方法,所以无法使用聚焦等方式

```
const Search = ({value, onChange, onSubmit, children="搜索"}) => {
    let input;
    return (
        <form onSubmit={onSubmit}>
            <input type="text" value={value} onChange={onChange}
                ref={(node) => input = node}/>
            <button type="submit">{children}</button>
        </form>
    );
};
```

### 加载

```
import React,{Component} from "react";
import './App.css';
import PropTypes from "prop-types";

const DEFAULT_QUERY = 'redux';
const PATH_BASE = 'https://hn.algolia.com/api/v1';
const PATH_SEARCH = '/search';
const PARAM_SEARCH = 'query=';
const PARAM_PAGE = 'page=';
class App extends Component {
    constructor(){
        super();
        this.state = {
            results:null,
            searchKey:"",
            searchTerm:DEFAULT_QUERY,
            error:null,
            isloading:false																							增加一个用于记录是否加载中
        };
        this.onChange = this.onChange.bind(this);
        this.setSearchTopStories = this.setSearchTopStories.bind(this);
        this.fetchSearchTopStories = this.fetchSearchTopStories.bind(this);
        this.onDismiss = this.onDismiss.bind(this);
        this.onSearchSubmit = this.onSearchSubmit.bind(this);
        this.needsToSearchTopStories = this.needsToSearchTopStories.bind(this);
    }
    onDismiss(objectID){
        const { searchKey, results } = this.state;
        const { hits, page } = results[searchKey];
        const isNotId = item => item.objectID !== objectID;
        const updatedHits = hits.filter(isNotId);
        this.setState({
            results: {
                ...results,
                [searchKey]: { hits: updatedHits, page }
            }
        })
    }
    onChange(event){
        this.setState({searchTerm:event.target.value});
    }
    needsToSearchTopStories(searchTerm){
        return !this.state.results[searchTerm];
    }
    onSearchSubmit(event) {
        const { searchTerm } = this.state;
        this.setState({searchKey : searchTerm});
        if (this.needsToSearchTopStories(searchTerm)) {
            this.fetchSearchTopStories(searchTerm);
        }
        event.preventDefault();
    }
    setSearchTopStories(result) {
        const { hits, page } = result;
        const { searchKey, results } = this.state;
        const oldHits = results && results[searchKey]
            ? results[searchKey].hits
            : [];
        const updatedHits = [
            ...oldHits,
            ...hits
        ];
        this.setState({
            isloading:false,																				加载结束后将状态改为false
            results: {
                    ...results,
                    [searchKey]: { hits: updatedHits, page }}
        });
        console.log(this.state);
    }
    fetchSearchTopStories(searchTerm,page=0) {
        this.setState({isloading:true});																			将加载状态改为true
        fetch(`${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}&${PARAM_PAGE}${page}`)
            .then(response => response.json())
            .then(result => this.setSearchTopStories(result))
            .catch(e => this.setState({error: e}));
    }
    componentDidMount() {
        const { searchTerm } = this.state;
        this.setState({searchKey : searchTerm});
        this.fetchSearchTopStories(searchTerm);
    }
    render(){
        console.log(this.state);
        const {results, searchKey, searchTerm, error, isloading} = this.state;
        const page = (results&&results[searchKey]&&results[searchKey].page)||0;
        const list = (results&&results[searchKey]&&results[searchKey].hits)||[];
        return (
            <div>
                <Search value={searchTerm} onChange={this.onChange} onSubmit={this.onSearchSubmit}/>
                {error
                    ?<p>请求失败,你被封杀了.</p>
                    :<Table list={list} onDismiss={this.onDismiss}/>}
                {isloading																								判断是否处于加载状态,加载中使用loading
                    ?<Loading />
                    :<button onClick={() => this.fetchSearchTopStories(searchKey, page+1)}>more</button>
                    }
            </div>
        );
    }
}
class Search extends Component {
    componentDidMount() {
        if(this.input){
            this.input.focus();
        }
    }
    render(){
        const {value,onChange,onSubmit,children="搜索"} = this.props;
        return(
            <form onSubmit={onSubmit}>
                <input type="text" value={value} onChange={onChange}
                       ref={(node) => { this.input=node; }}/>
                <button type="submit">{children}</button>
            </form>
        );
    }
}
Search.propTypes = {
    value: PropTypes.string.isRequired,
    onChange: PropTypes.func.isRequired,
    onSubmit: PropTypes.func.isRequired,
    children: PropTypes.string,
};
class Table extends Component {
    render(){
        const {list,onDismiss} = this.props;
        return(
            <div className="table">
            {list.map(function(item){
                return (
                    <div key={item.objectID}>
                        <h1>{item.title}</h1>
                        <h2>{item.author}</h2>
                        <h3>{item.points}</h3>
                        <button onClick={()=>onDismiss(item.objectID)} type="button">删除</button>
                    </div>
                );
            })}
            </div>
        );
    }
}
Table.propTypes = {
    list: PropTypes.arrayOf(
        PropTypes.shape({
            objectID: PropTypes.string.isRequired,
            author: PropTypes.string,
            url: PropTypes.string,
            num_comments: PropTypes.number,
            points: PropTypes.number,
        })
    ).isRequired,
    onDismiss: PropTypes.func.isRequired,
};
const Loading = () => <div>Loading ...</div>;
export default App;
export { Search, Table };
```

### 高阶组件

```
import React, {Component} from "react";
import './App.css';
import PropTypes from "prop-types";

const DEFAULT_QUERY = 'redux';
const PATH_BASE = 'https://hn.algolia.com/api/v1';
const PATH_SEARCH = '/search';
const PARAM_SEARCH = 'query=';
const PARAM_PAGE = 'page=';

class App extends Component {
    constructor() {
        super();
        this.state = {
            results: null,
            searchKey: "",
            searchTerm: DEFAULT_QUERY,
            error: null,
            isLoading: false,																					增加一个属性判断是否加载中
        };
        this.onChange = this.onChange.bind(this);
        this.setSearchTopStories = this.setSearchTopStories.bind(this);
        this.fetchSearchTopStories = this.fetchSearchTopStories.bind(this);
        this.onDismiss = this.onDismiss.bind(this);
        this.onSearchSubmit = this.onSearchSubmit.bind(this);
        this.needsToSearchTopStories = this.needsToSearchTopStories.bind(this);
    }

    onDismiss(objectID) {
        const {searchKey, results} = this.state;
        const {hits, page} = results[searchKey];
        const isNotId = item => item.objectID !== objectID;
        const updatedHits = hits.filter(isNotId);
        this.setState({
            results: {
                ...results,
                [searchKey]: {hits: updatedHits, page}
            }
        })
    }

    onChange(event) {
        this.setState({searchTerm: event.target.value});
    }

    needsToSearchTopStories(searchTerm) {
        return !this.state.results[searchTerm];
    }

    onSearchSubmit(event) {
        const {searchTerm} = this.state;
        this.setState({searchKey: searchTerm});
        if (this.needsToSearchTopStories(searchTerm)) {
            this.fetchSearchTopStories(searchTerm);
        }
        event.preventDefault();
    }

    setSearchTopStories(result) {
        const {hits, page} = result;
        const {searchKey, results} = this.state;
        const oldHits = results && results[searchKey]
            ? results[searchKey].hits
            : [];
        const updatedHits = [
            ...oldHits,
            ...hits
        ];
        this.setState({
            isLoading: false,																							结束后改变加载状态
            results: {
                ...results,
                [searchKey]: {hits: updatedHits, page}
            }
        });
    }

    fetchSearchTopStories(searchTerm, page = 0) {
        this.setState({isLoading: true});
        fetch(`${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}&${PARAM_PAGE}${page}`)
            .then(response => response.json())
            .then(result => this.setSearchTopStories(result))
            .catch(e => this.setState({error: e, isLoading:false}));						错误后改变加载状态
    }

    componentDidMount() {
        const {searchTerm} = this.state;
        this.setState({searchKey: searchTerm});
        this.fetchSearchTopStories(searchTerm);
    }

    render() {
        const {results, searchKey, searchTerm, error, isLoading} = this.state;
        const page = (results && results[searchKey] && results[searchKey].page) || 0;
        const list = (results && results[searchKey] && results[searchKey].hits) || [];
        console.log(this.state);
        return (
            <div>
                <Search value={searchTerm} onChange={this.onChange} onSubmit={this.onSearchSubmit}/>
                {error
                    ? <p>请求失败,你被封杀了.</p>
                    : <Table list={list} onDismiss={this.onDismiss}/>
                }
                <div>
                    <ButtonWithLoading isLoading={isLoading}										使用高阶组件
                        onClick={() => this.fetchSearchTopStories(searchKey, page + 1)}>
                    </ButtonWithLoading>
                </div>
            </div>
        );
    }
}

const Button = ({ onClick, children="More" }) =>							设定一个按钮	注意他的参数是({a,b,c})因为要解构
    <button onClick={onClick}  type="button">
        {children}
    </button>;

const Loading = () =>	
    <div>Loading ...</div>;

const withLoading = (Component) =>															设定高阶组件
    ({ isLoading, ...rest }) =>
        isLoading
            ? <Loading />
            : <Component { ...rest } />;

const ButtonWithLoading = withLoading(Button);									实例化

class Search extends Component {
    componentDidMount() {
        if (this.input) {
            this.input.focus();
        }
    }

    render() {
        const {value, onChange, onSubmit, children = "搜索"} = this.props;
        return (
            <form onSubmit={onSubmit}>
                <input type="text" value={value} onChange={onChange}
                       ref={(node) => {
                           this.input = node;
                       }}/>
                <button type="submit">{children}</button>
            </form>
        );
    }
}

Search.propTypes = {
    value: PropTypes.string.isRequired,
    onChange: PropTypes.func.isRequired,
    onSubmit: PropTypes.func.isRequired,
    children: PropTypes.string,
};

class Table extends Component {
    render() {
        const {list, onDismiss} = this.props;
        return (
            <div className="table">
                {list.map(function (item) {
                    return (
                        <div key={item.objectID}>
                            <h1>{item.title}</h1>
                            <h2>{item.author}</h2>
                            <h3>{item.points}</h3>
                            <button onClick={() => onDismiss(item.objectID)} type="button">删除</button>
                        </div>
                    );
                })}
            </div>
        );
    }
}

Table.propTypes = {
    list: PropTypes.arrayOf(
        PropTypes.shape({
            objectID: PropTypes.string.isRequired,
            author: PropTypes.string,
            url: PropTypes.string,
            num_comments: PropTypes.number,
            points: PropTypes.number,
        })
    ).isRequired,
    onDismiss: PropTypes.func.isRequired,
};
export default App;
```

### 排序

```
import React, {Component} from "react";
import './App.css';
import PropTypes from "prop-types";
import { sortBy } from 'lodash';												导包

const DEFAULT_QUERY = 'redux';
const PATH_BASE = 'https://hn.algolia.com/api/v1';
const PATH_SEARCH = '/search';
const PARAM_SEARCH = 'query=';
const PARAM_PAGE = 'page=';
const SORTS = {																									声明排序方式
    NONE: list => list,
    TITLE: list => sortBy(list, 'title'),
    AUTHOR: list => sortBy(list, 'author'),
    COMMENTS: list => sortBy(list, 'num_comments').reverse(),
    POINTS: list => sortBy(list, 'points').reverse(),
};
class App extends Component {
    constructor() {
        super();
        this.state = {
            results: null,
            searchKey: "",
            searchTerm: DEFAULT_QUERY,
            error: null,
            isLoading: false,
            sortKey: 'NONE',																								排序键
            isSortReverse: false,																						是否翻转
        };
        this.onChange = this.onChange.bind(this);
        this.setSearchTopStories = this.setSearchTopStories.bind(this);
        this.fetchSearchTopStories = this.fetchSearchTopStories.bind(this);
        this.onDismiss = this.onDismiss.bind(this);
        this.onSearchSubmit = this.onSearchSubmit.bind(this);
        this.needsToSearchTopStories = this.needsToSearchTopStories.bind(this);
        this.onSort = this.onSort.bind(this);															绑定排序函数
    }
    onSort(sortKey) {					如果当前的排序键和以前的相同则翻转,不相同则不翻转
        const isSortReverse = this.state.sortKey === sortKey && !this.state.isSortReverse;
        this.setState({ sortKey, isSortReverse});													提交并重绘
    }

    onDismiss(objectID) {
        const {searchKey, results} = this.state;
        const {hits, page} = results[searchKey];
        const isNotId = item => item.objectID !== objectID;
        const updatedHits = hits.filter(isNotId);
        this.setState({
            results: {
                ...results,
                [searchKey]: {hits: updatedHits, page}
            }
        })
    }

    onChange(event) {
        this.setState({searchTerm: event.target.value});
    }

    needsToSearchTopStories(searchTerm) {
        return !this.state.results[searchTerm];
    }

    onSearchSubmit(event) {
        const {searchTerm} = this.state;
        this.setState({searchKey: searchTerm});
        if (this.needsToSearchTopStories(searchTerm)) {
            this.fetchSearchTopStories(searchTerm);
        }
        event.preventDefault();
    }

    setSearchTopStories(result) {
        const {hits, page} = result;
        const {searchKey, results} = this.state;
        const oldHits = results && results[searchKey]
            ? results[searchKey].hits
            : [];
        const updatedHits = [
            ...oldHits,
            ...hits
        ];
        this.setState({
            isLoading: false,
            results: {
                ...results,
                [searchKey]: {hits: updatedHits, page}
            }
        });
    }

    fetchSearchTopStories(searchTerm, page = 0) {
        this.setState({isLoading: true});
        fetch(`${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}&${PARAM_PAGE}${page}`)
            .then(response => response.json())
            .then(result => this.setSearchTopStories(result))
            .catch(e => this.setState({error: e, isLoading:false}));
    }

    componentDidMount() {
        const {searchTerm} = this.state;
        this.setState({searchKey: searchTerm});
        this.fetchSearchTopStories(searchTerm);
    }

    render() {
        const {results, searchKey, searchTerm, error, isLoading, sortKey, isSortReverse} = this.state;
        const page = (results && results[searchKey] && results[searchKey].page) || 0;
        const list = (results && results[searchKey] && results[searchKey].hits) || [];
        console.log(this.state);
        return (
            <div>
                <Search value={searchTerm} onChange={this.onChange}
                        onSubmit={this.onSearchSubmit}/>
                {error
                    ? <p>请求失败,你被封杀了.</p>
                    : <Table list={list} onDismiss={this.onDismiss}					传入排序函数及排序参数
                             onSort={this.onSort} sortKey={sortKey} isSortReverse={isSortReverse}/>
                }
                <div>
                    <ButtonWithLoading
                        isLoading={isLoading}
                        onClick={() => this.fetchSearchTopStories(searchKey, page + 1)}>
                    </ButtonWithLoading>
                </div>
            </div>
        );
    }
}

const Button = ({onClick, children = "More"}) =>
    <button onClick={onClick} type="button">
        {children}
    </button>;

const withLoading = (Component) =>
    ({isLoading, ...rest}) =>
        (isLoading
            ? <Loading />
            : <Component {...rest}/>);

const ButtonWithLoading = withLoading(Button);

class Search extends Component {
    componentDidMount() {
        if (this.input) {
            this.input.focus();
        }
    }

    render() {
        const {value, onChange, onSubmit, children = "搜索"} = this.props;
        return (
            <form onSubmit={onSubmit}>
                <input type="text" value={value} onChange={onChange}
                       ref={(node) => {
                           this.input = node;
                       }}/>
                <button type="submit">{children}</button>
            </form>
        );
    }
}

Search.propTypes = {
    value: PropTypes.string.isRequired,
    onChange: PropTypes.func.isRequired,
    onSubmit: PropTypes.func.isRequired,
    children: PropTypes.string,
};

const Sort = ({ sortKey, onSort, children }) =>									定义一个排序组件,点击触发排序事件
    <Button onClick={() => onSort(sortKey)}>
        {children}
    </Button>;

class Table extends Component {
    render() {
        const {list, onDismiss, onSort, sortKey, isSortReverse} = this.props;
        const sortedList = SORTS[sortKey](list);																根据键得到排序后的列表
        const reverseSortedList = isSortReverse																	根据是否翻转得到翻转后的列表
            ? sortedList.reverse()
            : sortedList;
        return (
            <div className="table">
                <div className="table-header">
                    <span style={{ width: '40%' }}>												
                        <Sort sortKey={'TITLE'} onSort={onSort}>Title</Sort>					插入排序组件,传入排序函数
                    </span>
                    <span style={{ width: '30%' }}>
                        <Sort sortKey={'AUTHOR'} onSort={onSort}>Author</Sort>
                    </span>
                    <span style={{ width: '10%' }}>
                        <Sort sortKey={'COMMENTS'} onSort={onSort}>Comments</Sort>
                    </span>
                    <span style={{ width: '10%' }}>
                        <Sort sortKey={'POINTS'} onSort={onSort}>Points</Sort>
                    </span>
                    <span style={{ width: '10%' }}>Archive</span>
                </div>
                {reverseSortedList.map(function (item) {												对翻转后的列表进行遍历
                    return (
                        <div key={item.objectID}>
                            <h1>{item.title}</h1>
                            <h2>{item.author}</h2>
                            <h3>{item.points}</h3>
                            <button onClick={() => onDismiss(item.objectID)}
                                    type="button">删除</button>
                        </div>
                    );
                })}
            </div>
        );
    }
}

Table.propTypes = {
    list: PropTypes.arrayOf(
        PropTypes.shape({
            objectID: PropTypes.string.isRequired,
            author: PropTypes.string,
            url: PropTypes.string,
            num_comments: PropTypes.number,
            points: PropTypes.number,
        })
    ).isRequired,
    onDismiss: PropTypes.func.isRequired,
};
const Loading = () => <div>Loading ...</div>;
export default App;
```

## 进阶

### 状态提取

```
class Table extends Component {
    constructor(props){																				写构造函数,将单独的属性提取出来
        super(props);
        this.state={
            sortKey: 'NONE',
            isSortReverse: false,
        };
        this.onSort = this.onSort.bind(this);															单独的方法提取出来
    }
    onSort(sortKey) {
        const isSortReverse = this.state.sortKey === sortKey && !this.state.isSortReverse;
        this.setState({ sortKey, isSortReverse});												重构Table模块
    }
    render() {
        const {list, onDismiss } = this.props;															解构参数
        const {sortKey, isSortReverse} = this.state;											结构属性
        const sortedList = SORTS[sortKey](list);
        const reverseSortedList = isSortReverse
            ? sortedList.reverse()
            : sortedList;
        return (
            <div className="table">
                <div className="table-header">
                    <span style={{ width: '40%' }}>
                        <Sort sortKey={'TITLE'} onSort={this.onSort}>Title</Sort>							函数为this.函数名
                    </span>
                    <span style={{ width: '30%' }}>
                        <Sort sortKey={'AUTHOR'} onSort={this.onSort}>Author</Sort>
                    </span>
                    <span style={{ width: '10%' }}>
                        <Sort sortKey={'COMMENTS'} onSort={this.onSort}>Comments</Sort>
                    </span>
                    <span style={{ width: '10%' }}>
                        <Sort sortKey={'POINTS'} onSort={this.onSort}>Points</Sort>
                    </span>
                    <span style={{ width: '10%' }}>Archive</span>
                </div>
                {reverseSortedList.map(function (item) {
                    return (
                        <div key={item.objectID}>
                            <h1>{item.title}</h1>
                            <h2>{item.author}</h2>
                            <h3>{item.points}</h3>
                            <button onClick={() => onDismiss(item.objectID)}
                                    type="button">删除</button>
                        </div>
                    );
                })}
            </div>
        );
    }
}
```

### setState()函数式

```
    onDismiss(objectID) {
        const isNotId = item => item.objectID !== objectID;
        this.setState((prevState)=>{
            const {searchKey, results} = prevState;
            const {hits, page} = results[searchKey];
            const updatedHits = hits.filter(isNotId);
            console.log(updatedHits,searchKey);
            return({
                results: {
                    ...results,
                    [searchKey]: {hits: updatedHits, page}
                }
            });
        });
    }
    onSearchSubmit(event) {
        this.setState((prevState)=>{
            const {searchTerm} = prevState;
            return{ searchKey: searchTerm };
        });
        const {searchTerm} = this.state;
        if (this.needsToSearchTopStories(searchTerm)) {
            this.fetchSearchTopStories(searchTerm);
        }
        event.preventDefault();
    }
    setSearchTopStories(result) {
        this.setState((prevState) => {
            const {hits, page} = result;
            const {searchKey, results} = prevState;
            const oldHits = results && results[searchKey]
                ? results[searchKey].hits
                : [];
            const updatedHits = [
                ...oldHits,
                ...hits
            ];
            return{
                isLoading: false,
                results: {
                    ...results,
                    [searchKey]: {hits: updatedHits, page}}};
        });
    }
    componentDidMount() {
        this.setState((prepState) =>{
            const {searchTerm} = prepState;
            return{
                searchKey: searchTerm
            };
        });
        const {searchTerm} = this.state;
        this.fetchSearchTopStories(searchTerm);
    }
    onSort(sortKey) {
        this.setState((prepState)=>{
            const isSortReverse = prepState.sortKey === sortKey && !prepState.isSortReverse;
            return{sortKey, isSortReverse};
        });
    }
```

## 其他

### 数据库

连接到数据库和/或认证:在一个不断增长的 React 应用程序中,你可能希望最终能够持久化存储数据。数据应该存储在数据库中,以便于浏览器会话结束后仍可继续使用,并能在应用程序的不同用户之间进行共享。引入数据库最简单的方法就是使用 Firebase。在这个全面的教程152当中,你会找到一份如何在 React 中使用 Firebase 进行身份验证(注册、登录、注销、...)且循序渐进的指南。除此之外,你还将使用Firebase 的实时数据库来存储用户实体。在此之后,你可以为你的应用程序存储更多的数据。

### 测试

这本书对测试的涉及尚浅。如果你对测试这个大话题还不太熟悉的话,你应该尝试进一步了解单元测和集成测试的相关概念,特别是在 React 应用的上下文里面。从实现层面上来说,我会强烈推荐 Enzyme 和 Jest,通过单元测试和快照测试来改善你的 React 测试手法。

### 异步请求

你可以使用执行异步请求的第三方库来替代原生的 fetch API: superagent153或 axios154。发送异步请求并没有完美的解决方案。但是通过更换 React 外围的组成部分,你可以切身体会到在 React 当中拥有这种灵活性是多么的强大155。在某些框架中通常你只能使用某一种方案,但是在诸如 React 这样的灵活的生态系统156当中,你可以任意更换解决方案。

### 路由

你可以使用 react-router157 为你的应用程序实现路由功能。到目前为止,你的应用程序还只有一个页面。React Router 则能够让你跨多个 URL 创建多个页面。在将路由引入你的应用之后,你不需要发送任何请求到服务端去获取下个页面。路由器(Router)将会帮你在客户端搞定一切。

### 类型检查

在某个章节,你已经使用过 React PropTypes 来定义组件接口。这是预防bugs 的一种良好实践,但是 PropTypes 只能在运行时执行检查。你可以更进一步地,在编译时就引入静态类型检查。TypeScript158 就是备受欢迎的手段之一。但在 React生态当中,通常情况下大家会使用 Flow159。如果你想要让你的应用程序更加健壮的话,我会推荐你去尝试一下 Flow。

### Webpack 和 Babel 

在本书中你已经使用过 create-react-app 来创建应用程序。到了某个节点,当你已经对 React 足够了解的时候,你可能就想要学习跟 React相关的一些工具。这可以让你不用 create-react-app 也能初始化自己的项目。我会推荐你先了解如何使用 Webpack 和 Babel160 完成最少量的配置,然后你可以根据自己的情况去实践更多的工具。例如,你可以在应用程序中使用 ESLint161 来统一代码风格。

### React Native

React Native162 可以将你的应用程序带到移动设备上。React Native 使你能够把在 React 中所学到的知识应用到 iOS 和 Android 应用当中去。一旦你学会了React,React Native 的学习曲线就应该不会那么陡峭,两者都是相同的原则和理念。你只是会在移动设备上碰到一些跟 Web 应用有所不同的布局组件。	